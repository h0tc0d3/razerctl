#include "razer.h"
#include "device.h"

#ifdef RAZERCTL_USE_LIBUSB
#include "libusb.h"
#endif
#ifdef RAZERCTL_USE_HIDRAW
#include "hidraw.h"
#endif

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#ifdef _WIN32
#include <windows.h>
#endif

#if defined(RAZERCTL_USE_LIBUSB) && defined(RAZERCTL_USE_HIDRAW)
#define RAZER_SEND_REQUEST razer_send_request(device, &request, &response, (uint8_t) settings->libusb)
#else
#define RAZER_SEND_REQUEST razer_send_request(device, &request, &response)
#endif

/**
 *  Dublicate string
 */
char *razer_strdup(const char *string)
{
    char *new_string = NULL;
    if (string) {
        size_t size = strlen(string);
        new_string = (char *) calloc(size + 1, sizeof(char));
        if (new_string)
            strcpy(new_string, string);
    }
    return new_string;
}

/**
 * Round value to 5
 */
uint8_t razer_round5(uint8_t value)
{
    uint8_t tmp = (uint8_t) (value / 5) * 5;
    uint8_t remainder = value - tmp;
    if (remainder > 2)
        return tmp + 5;
    return tmp;
}

/**
 * Calculate the checksum for the usb message
 *
 * Checksum byte is stored in the 2nd last byte in the messages payload.
 * The checksum is generated by XORing all the bytes in the report starting
 * at byte number 2 (0 based) and ending at byte 88.
 */
uint8_t razer_data_crc(struct razer_report *report)
{
    /*second to last byte of report is a simple checksum*/
    /*just xor all bytes up with overflow and you are done*/
    uint8_t crc = 0;
    uint8_t *_report = (uint8_t *) report;
    for (size_t i = 2; i <= 88; i++) {
        crc ^= _report[i];
    }
    return crc;
}

/**
 * Print Error MSG
 */
void razer_print_error(struct razer_report *report, const char *message)
{
    fprintf(stderr,
            "Error: %s.\nStatus: %02x\nId: %02x\nProtocol Type: %02x\n"
            "Command Class: %02x\nCommand Id: %02x\nArgs Bytes: "
            "%02x\nRemaining Packets: %02x\n"
            "Args: %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\n\n",
            message, report->status, report->transaction_id, report->protocol_type, report->command_class,
            report->command_id, report->data_size, report->remaining_packets, report->arguments[0],
            report->arguments[1], report->arguments[2], report->arguments[3], report->arguments[4],
            report->arguments[5], report->arguments[6], report->arguments[7], report->arguments[8],
            report->arguments[9], report->arguments[10], report->arguments[11], report->arguments[12],
            report->arguments[13], report->arguments[14], report->arguments[15]);
}

#if defined(RAZERCTL_USE_LIBUSB) && defined(RAZERCTL_USE_HIDRAW)
int razer_send_request(void *device, struct razer_report *request, struct razer_report *response, bool libusb)
#else
int razer_send_request(void *device, struct razer_report *request, struct razer_report *response)
#endif
{
    int err;

    request->crc = razer_data_crc(request);

send_request:
#if defined(RAZERCTL_USE_LIBUSB) && defined(RAZERCTL_USE_HIDRAW)
    if (libusb)
        err = razer_libusb_get_response(device, request, response);
    else
        err = razer_hidraw_get_response(device, request, response);
#elif defined(RAZERCTL_USE_HIDRAW)
    err = razer_hidraw_get_response(device, request, response);
#else
    err = razer_libusb_get_response(device, request, response);
#endif

    if (err)
        return err;

    /* Check the packet number, class and command are the same */
    if (response->remaining_packets != request->remaining_packets || response->command_class != request->command_class
        || response->command_id != request->command_id) {
        razer_print_error(response, "Response doesn't match request");
        return -1;
    }

    switch (response->status) {
        case RAZER_SUCCESSFUL:
            return 0;
        case RAZER_BUSY:
            // printf("Device is busy!\n");
            RAZER_SLEEP;
            goto send_request;
        case RAZER_FAILURE:
            razer_print_error(response, "Command failed");
            return -1;
        case RAZER_NOT_SUPPORTED:
            razer_print_error(response, "Command not supported");
            return -1;
        case RAZER_TIMEOUT:
            // printf("Command timed out!\n");
            RAZER_SLEEP;
            goto send_request;
        default:
            razer_print_error(response, "Unknown command error");
            return -1;
    }
}

/**
 * Parse device file "dpi_stages"
 * Each DPI stage is described by 4 bytes:
 *   - 2 bytes (unsigned short) for x-axis DPI
 *   - 2 bytes (unsigned short) for y-axis DPI
 *
 * Always writes 1+n*4 bytes:
 *   - 1 byte: active DPI stage number, >= 0 and <= n.
 *   - n*4 bytes: n DPI stages.
 */

uint8_t razer_parse_dpi_stages(struct razer_report *response, uint8_t *active_stage, struct mouse_dpi *dpi_stages)
{
    // Response format (hex):
    // 01    varstore
    // 02    active DPI stage
    // 04    number of stages = 4
    //
    // 01    first DPI stage
    // 03 20 first stage DPI X = 800
    // 03 20 first stage DPI Y = 800
    // 00 00 reserved
    //
    // 02    second DPI stage
    // 07 08 second stage DPI X = 1800
    // 07 08 second stage DPI Y = 1800
    // 00 00 reserved
    //
    // 03    third DPI stage
    // ...
    uint8_t count = response->arguments[2];
    if (count == 0 && count >= MAX_DPI_STAGES)
        return 0;

    *active_stage = response->arguments[1] - 1;

    uint8_t *dpi_stage = response->arguments + 4; // pointer to the next dpi value in response.arguments
    for (size_t i = 0; i < count; i++) {
        // Check that we don't read past response.data_size
        if (dpi_stage + 4 > response->arguments + response->data_size) {
            break;
        }

        dpi_stages[i].x = (uint16_t) ((dpi_stage[0] << 8) | (dpi_stage[1] & 0xFF));
        dpi_stages[i].y = (uint16_t) ((dpi_stage[2] << 8) | (dpi_stage[3] & 0xFF));

        dpi_stage += 7;
    }

    return count;
}

int razer_device_iterate(struct razerctl_settings *settings, size_t id, void *device)
{

    int result = 0;
    struct razer_report request = { 0 };
    struct razer_report response = { 0 };

    if (settings->set_polling_rate) {
        if (razer_mouse[id].attr.hyper_polling) {
            if (settings->polling_rate == 125 || settings->polling_rate == 500 || settings->polling_rate == 1000
                || settings->polling_rate == 2000 || settings->polling_rate == 4000 || settings->polling_rate == 8000) {
                set_polling_rate2(&request, settings->polling_rate, 0x00);
                result = RAZER_SEND_REQUEST;
                if (result) {
                    set_polling_rate2(&request, settings->polling_rate, 0x01);
                    result = RAZER_SEND_REQUEST;
                }
            } else {
                printf("Can't set unknown polling rate value: %d. Avaible values: 125, 500, 1000, 2000, 4000, 8000\n\n",
                       settings->polling_rate);
                result = -1;
            }
            if (result)
                return result;
        } else {
            if (settings->polling_rate == 125 || settings->polling_rate == 500 || settings->polling_rate == 1000) {
                set_polling_rate(&request, settings->polling_rate);
                result = RAZER_SEND_REQUEST;
            } else {
                printf("Can't set unknown polling rate value: %d. Avaible values: 125, 500, 1000\n\n",
                       settings->polling_rate);
                result = -1;
            }
            if (result)
                return result;
        }
    }

    if (razer_mouse[id].attr.dpi_stages) {
        if (settings->set_dpi_stages) {
            if (settings->active_stage > settings->stages_count) {
                printf("Incorrect active DPI stage %hhu\n", settings->active_stage);
                return result;
            }
            if (!settings->active_stage){
                settings->active_stage = 1;
            }
            set_dpi_stages(&request, settings->stages_count, settings->active_stage,
                           (const struct mouse_dpi *) &settings->dpi_stages);
            result = RAZER_SEND_REQUEST;
            if (result)
                return result;
        }

        if (settings->set_active_stage && !settings->set_dpi_stages) {
            get_dpi_stages(&request, 0x01);
            result = RAZER_SEND_REQUEST;
            uint8_t active_stage = 0;

            settings->stages_count
              = razer_parse_dpi_stages(&response, &active_stage, (struct mouse_dpi *) &settings->dpi_stages);

            if (settings->stages_count > 0) {
                if (settings->active_stage > settings->stages_count) {
                    printf("Incorrect active DPI stage %hhu\n", settings->active_stage);
                    return result;
                }

                set_dpi_stages(&request, settings->stages_count, settings->active_stage,
                               (const struct mouse_dpi *) &settings->dpi_stages);
                result = RAZER_SEND_REQUEST;

                if (result)
                    return result;
            }
        }
    }

    if (settings->set_dpi) {
        set_dpi_xy(&request, settings->dpi.x, settings->dpi.y);
        result = RAZER_SEND_REQUEST;
        if (result)
            return result;
    }

    if (settings->set_idle_time) {
        set_idle_time(&request, settings->idle_time);
        result = RAZER_SEND_REQUEST;
        if (result)
            return result;
    }

    if (settings->set_battery_threshold) {
        set_low_battery_threshold(&request, settings->battery_threshold);
        result = RAZER_SEND_REQUEST;
        if (result)
            return result;
    }

    if (razer_mouse[id].attr.async_lod) {
        if (settings->set_lod) {
            set_lod_async_off(&request);
            result = RAZER_SEND_REQUEST;
            if (result)
                return result;
            set_lod(&request, settings->lod);
            result = RAZER_SEND_REQUEST;
            if (result)
                return result;
        }
        if (settings->set_async_lod) {
            set_lod_async_on(&request);
            result = RAZER_SEND_REQUEST;
            if (result)
                return result;
            set_lod_async_on_step2(&request);
            result = RAZER_SEND_REQUEST;
            if (result)
                return result;
            set_async_lod(&request, settings->lod, settings->ld);
            result = RAZER_SEND_REQUEST;
            if (result)
                return result;
        }
    }

    result = razer_device_info(settings, id, device);

    return result;
}

int razer_device_info(struct razerctl_settings *settings, size_t id, void *device)
{
    int result;
    char serial_number[23];
    uint16_t polling_rate = 0;
    struct mouse_dpi dpi = { 0 };
    struct mouse_dpi dpi_stages[MAX_DPI_STAGES] = { 0 };
    uint8_t active_stage = 1;
    uint16_t idle_time = 0;

    struct razer_report request = { 0 };
    struct razer_report response = { 0 };
    const char *indent;

    if (settings->device)
        indent = "    ";
    else
        indent = "        ";

    if (razer_mouse[id].attr.battery) {
        get_charging_status(&request);
        result = RAZER_SEND_REQUEST;
        if (result)
            return result;

        if (response.arguments[1])
            if (settings->json)
                printf("%s\"charging\": true,\n", indent);
            else
                printf("Charging: true\n");
        else if (settings->json)
            printf("%s\"charging\": false,\n", indent);
        else
            printf("Charging: false\n");

        get_battery_level(&request);
        result = RAZER_SEND_REQUEST;
        if (result)
            return result;

        if (settings->json)
            printf("%s\"battery\": \"%d%%\",\n", indent, (response.arguments[1] * 100 / 255));
        else
            printf("Battery: %d%%\n", (response.arguments[1] * 100 / 255));

        get_low_battery_threshold(&request);
        result = RAZER_SEND_REQUEST;
        if (result)
            return result;

        if (settings->json)
            printf("%s\"battery_threshold\": \"%d%%\",\n", indent, razer_round5(response.arguments[0] * 100 / 255));
        else
            printf("Battery Threshold: %d%%\n", razer_round5(response.arguments[0] * 100 / 255));

        get_idle_time(&request);
        result = RAZER_SEND_REQUEST;
        if (result)
            return result;

        idle_time = (uint16_t) ((response.arguments[0] << 8) | (response.arguments[1] & 0xFF));
        if (settings->json)
            printf("%s\"idle_time\": %u,\n", indent, idle_time);
        else
            printf("Idle Time: %us\n", idle_time);
    }

    if (razer_mouse[id].attr.hyper_polling) {
        get_polling_rate2(&request);
        result = RAZER_SEND_REQUEST;
        if (result)
            return result;
        switch (response.arguments[1]) {
            case 0x01:
                polling_rate = 8000;
                break;
            case 0x02:
                polling_rate = 4000;
                break;
            case 0x04:
                polling_rate = 2000;
                break;
            case 0x08:
                polling_rate = 1000;
                break;
            case 0x10:
                polling_rate = 500;
                break;
            case 0x40:
                polling_rate = 125;
                break;
        }
    } else {
        get_polling_rate(&request);
        result = RAZER_SEND_REQUEST;
        if (result)
            return result;
        switch (response.arguments[0]) {
            case 0x01:
                polling_rate = 1000;
                break;
            case 0x02:
                polling_rate = 500;
                break;
            case 0x08:
                polling_rate = 125;
                break;
        }
    }

    if (settings->json)
        printf("%s\"polling_rate\": %d,\n", indent, polling_rate);
    else
        printf("Polling Rate: %dHZ\n", polling_rate);

    if (razer_mouse[id].attr.async_lod) {
        get_lod(&request);
        result = RAZER_SEND_REQUEST;
        if (result)
            return result;
        if (response.arguments[2] == 0x01) {
            const char *lod;
            if (response.arguments[3] == RAZER_LOD_LOW) {
                lod = "low";
            } else if (response.arguments[3] == RAZER_LOD_MEDIUM) {
                lod = "medium";
            } else if (response.arguments[3] == RAZER_LOD_HIGH) {
                lod = "high";
            } else {
                lod = "unknown";
            }
            if (settings->json)
                printf("%s\"lod_async\": 0,\n%s\"lod\": \"%s\",\n", indent, indent, lod);
            else
                printf("Lift-Off Distance: %s\n", lod);
        } else if (response.arguments[2] == 0x04) {
            if (settings->json)
                printf("%s\"lod_async\": 1,\n%s\"lod\": %d,\n%s\"ld\": %d,\n", indent, indent,
                       response.arguments[4] + 1, indent, response.arguments[5] + 1);
            else
                printf("Lift-Off Distance: %d\nLand Distance: %d\n", response.arguments[4] + 1,
                       response.arguments[5] + 1);
        }
    }

    get_dpi_xy(&request);
    result = RAZER_SEND_REQUEST;
    if (result)
        return result;

    dpi.x = (uint16_t) ((response.arguments[1] << 8) | (response.arguments[2] & 0xFF));
    dpi.y = (uint16_t) ((response.arguments[3] << 8) | (response.arguments[4] & 0xFF));

    if (settings->json)
        printf("%s\"dpi\": \"%hux%hu\",\n", indent, dpi.x, dpi.y);
    else
        printf("DPI: %hux%hu\n", dpi.x, dpi.y);

    if (razer_mouse[id].attr.dpi_stages) {
        get_dpi_stages(&request, 0x01);
        result = RAZER_SEND_REQUEST;
        if (result)
            return result;
        result = razer_parse_dpi_stages(&response, &active_stage, (struct mouse_dpi *) &dpi_stages);
        if (result > 0) {
            if (settings->json)
                printf("%s\"dpi_stages\": [", indent);
            else
                printf("DPI Stages: ");
            for (int i = 0; i < result; i++) {
                if (!settings->json && i == active_stage) {
                    printf("!");
                }
                if (settings->json)
                    if (i == result - 1)
                        printf("\"%hux%hu\"", dpi_stages[i].x, dpi_stages[i].y);
                    else
                        printf("\"%hux%hu\", ", dpi_stages[i].x, dpi_stages[i].y);
                else
                    printf("[%d] %hux%hu  ", i + 1, dpi_stages[i].x, dpi_stages[i].y);
            }
            if (settings->json)
                printf("],\n%s\"active_stage\": %hu,\n", indent, active_stage + 1);
            else
                printf("\n");
        }
    }

    get_firmware_version(&request);
    result = RAZER_SEND_REQUEST;
    if (result)
        return result;
    if (settings->json)
        printf("%s\"firmware\": \"v%d.%d\",\n", indent, response.arguments[0], response.arguments[1]);
    else
        printf("Firmware: v%d.%d\n", response.arguments[0], response.arguments[1]);

    get_serial(&request);
    result = RAZER_SEND_REQUEST;
    if (result)
        return result;
    strncpy(&serial_number[0], (const char *) &response.arguments[0], 22);
    serial_number[22] = '\0';
    if (settings->json)
        printf("%s\"serial\": \"%s\"\n", indent, serial_number);
    else
        printf("Serial Number: %s\n\n", serial_number);

    return result;
}

/**
 * Get initialised razer report
 */
static inline void razer_reset_report(struct razer_report *report, uint8_t command_class, uint8_t command_id,
                                      uint8_t data_size)
{
    memset(report, 0, sizeof(struct razer_report));
    report->status = RAZER_NEW;
    report->transaction_id = 0x1f; // 0x00
    report->remaining_packets = 0x00;
    report->protocol_type = 0x00;
    report->command_class = command_class;
    report->command_id = command_id;
    report->data_size = data_size;
}

/**
 * Get serial from device
 */
void get_serial(struct razer_report *report)
{
    razer_reset_report(report, 0x00, 0x82, 0x16);
}

/**
 * Get firmware version from device
 */
void get_firmware_version(struct razer_report *report)
{
    razer_reset_report(report, 0x00, 0x81, 0x02);
}

/**
 * Get the polling rate from the device
 *
 * Identifier is in arg[0]
 *
 * 0x01 = 1000Hz
 * 0x02 =  500Hz
 * 0x08 =  125Hz
 */
void get_polling_rate(struct razer_report *report)
{
    razer_reset_report(report, 0x00, 0x85, 0x01);
}

void set_polling_rate(struct razer_report *report, uint16_t polling_rate)
{
    razer_reset_report(report, 0x00, 0x05, 0x01);
    switch (polling_rate) {
        case 1000:
            report->arguments[0] = 0x01;
            break;
        case 500:
            report->arguments[0] = 0x02;
            break;
        case 125:
            report->arguments[0] = 0x08;
            break;
        default: // 500Hz
            report->arguments[0] = 0x02;
            break;
    }
}

/**
 * Get the polling rate from the device
 *
 * Identifier is in arg[1]
 *
 * 0x01 = 8000Hz
 * 0x02 = 4000Hz
 * 0x04 = 2000Hz
 * 0x08 = 1000Hz
 * 0x10 =  500Hz
 * 0x40 =  125Hz
 */
void get_polling_rate2(struct razer_report *report)
{
    razer_reset_report(report, 0x00, 0xC0, 0x01);
}

/**
 * Set the polling rate of the device
 *
 * 0x40 =  125 Hz
 * 0x10 =  500 Hz
 * 0x08 = 1000 Hz
 * 0x04 = 2000 Hz
 * 0x02 = 4000 Hz
 * 0x01 = 8000 Hz
 */
void set_polling_rate2(struct razer_report *report, uint16_t polling_rate, uint8_t argument)
{
    razer_reset_report(report, 0x00, 0x40, 0x02);
    report->arguments[0] = argument; // For some devices Razer sends each request
    // once with 0x00 and once with 0x01 - maybe varstore?
    switch (polling_rate) {
        case 8000:
            report->arguments[1] = 0x01;
            break;
        case 4000:
            report->arguments[1] = 0x02;
            break;
        case 2000:
            report->arguments[1] = 0x04;
            break;
        case 1000:
            report->arguments[1] = 0x08;
            break;
        case 500:
            report->arguments[1] = 0x10;
            break;
        case 250:
            report->arguments[1] = 0x20;
            break;
        case 125:
            report->arguments[1] = 0x40;
            break;
        default: // 500Hz
            report->arguments[1] = 0x10;
            break;
    }
}

/**
 * Gets battery level
 *
 * 0->255 is in arg[1]
 */
void get_battery_level(struct razer_report *report)
{
    razer_reset_report(report, 0x07, 0x80, 0x02);
}

/**
 * Gets charging status
 *
 * 0->1 is in arg[1]
 */
void get_charging_status(struct razer_report *report)
{
    razer_reset_report(report, 0x07, 0x84, 0x02);
}

/**
 * Get the DPI of the device
 */
void get_dpi_xy(struct razer_report *report)
{
    razer_reset_report(report, 0x04, 0x85, 0x07);
    report->arguments[0] = 0x00;
}

/**
 * Clamp a value to a min,max
 */
uint8_t clamp_u8(uint8_t value, uint8_t min, uint8_t max)
{
    if (value > max)
        return max;
    if (value < min)
        return min;
    return value;
}

uint16_t clamp_u16(uint16_t value, uint16_t min, uint16_t max)
{
    if (value > max)
        return max;
    if (value < min)
        return min;
    return value;
}

/**
 * Set the DPI of the device
 */
void set_dpi_xy(struct razer_report *report, uint16_t dpi_x, uint16_t dpi_y)
{
    razer_reset_report(report, 0x04, 0x05, 0x07);
    // Keep the DPI within bounds
    dpi_x = clamp_u16(dpi_x, 100, 30000);
    dpi_y = clamp_u16(dpi_y, 100, 30000);

    report->arguments[0] = 0x00;
    report->arguments[1] = (dpi_x >> 8) & 0x00FF;
    report->arguments[2] = dpi_x & 0x00FF;
    report->arguments[3] = (dpi_y >> 8) & 0x00FF;
    report->arguments[4] = dpi_y & 0x00FF;
    report->arguments[5] = 0x00;
    report->arguments[6] = 0x00;
}

/**
 * Get the DPI stages of the device
 */
void get_dpi_stages(struct razer_report *report, uint8_t variable_storage)
{
    razer_reset_report(report, 0x04, 0x86, 0x26);
    report->arguments[0] = variable_storage;
}

/**
 * Set DPI stages of the device.
 *
 * count is the number of stages to set.
 * active_stage selected stage number.
 * dpi is an array of size 2 * count containing pairs of dpi x and dpi y
 * values, one pair for each stage.
 *
 * E.g.:
 *   count = 3
 *   active_stage = 1
 *   dpi = [ 800, 800, 1800, 1800, 3200, 3200]
 *         | stage 1*|  stage 2  |  stage 3  |
 */
void set_dpi_stages(struct razer_report *report, uint8_t quantity, uint8_t active_stage,
                    const struct mouse_dpi *dpi_stages)
{

    razer_reset_report(report, 0x04, 0x06, 0x26);

    report->arguments[0] = 0x01;
    report->arguments[1] = active_stage;
    report->arguments[2] = quantity;

    uint8_t offset = 3;
    for (uint8_t i = 0; i < quantity; i++) {
        // Stage number
        report->arguments[offset++] = i;

        // DPI X
        report->arguments[offset++] = (dpi_stages[i].x >> 8) & 0x00FF;
        report->arguments[offset++] = dpi_stages[i].x & 0x00FF;

        // DPI Y
        report->arguments[offset++] = (dpi_stages[i].y >> 8) & 0x00FF;
        report->arguments[offset++] = dpi_stages[i].y & 0x00FF;

        // Reserved
        report->arguments[offset++] = 0;
        report->arguments[offset++] = 0;
    }
}

/**
 * Get device idle time
 */
void get_idle_time(struct razer_report *report)
{
    razer_reset_report(report, 0x07, 0x83, 0x02);
}

/**
 * Set device idle time
 * Device will go into power-save after this time.
 * Idle time is in seconds, must be between 60sec-900sec
 */
void set_idle_time(struct razer_report *report, uint16_t idle_time)
{
    razer_reset_report(report, 0x07, 0x03, 0x02);
    // Keep the idle time within bounds
    idle_time = clamp_u16(idle_time, 60, 900);
    report->arguments[0] = (idle_time >> 8) & 0x00FF;
    report->arguments[1] = idle_time & 0x00FF;
}

/**
 * Get low battery threshold
 */
void get_low_battery_threshold(struct razer_report *report)
{
    razer_reset_report(report, 0x07, 0x81, 0x01);
}

/**
 * Set low battery threshold
 * 0xFF = 100%
 * 0x7F = 50%
 * 0x3F = 25%
 * 0x33 = 20%
 * 0x26 = 15%
 * 0x19 = 10%
 * 0x0C = 5%
 */
void set_low_battery_threshold(struct razer_report *report, uint8_t threshold)
{
    razer_reset_report(report, 0x07, 0x01, 0x01);
    threshold = razer_round5(threshold * 255 / 100); // 0 - 100%, step 5%
    threshold = clamp_u8(threshold, 0x0C, 0xFF);     // 5 - 100%; min value = 5%
    report->arguments[0] = threshold;
}

/**
 * Get lift-off distance
 */
void get_lod(struct razer_report *report)
{
    razer_reset_report(report, 0x0b, 0x85, 0x01);
}

/**
 * Set lift-off distance value
 */
void set_lod(struct razer_report *report, uint8_t lod)
{
    lod = clamp_u8(lod, 0, 2);
    razer_reset_report(report, 0x0b, 0x0b, 0x04);
    report->arguments[0] = 00;
    report->arguments[1] = 04;
    report->arguments[2] = 01;
    report->arguments[3] = lod;
}

/**
 * Set Async Off lift-off distance
 */
void set_lod_async_off(struct razer_report *report)
{
    razer_reset_report(report, 0x0b, 0x03, 0x03);
    report->arguments[0] = 00;
    report->arguments[1] = 04;
    report->arguments[2] = 40;
}

/**
 * Set Async On lift-off distance
 */
void set_lod_async_on(struct razer_report *report)
{
    razer_reset_report(report, 0x0b, 0x03, 0x03);
    report->arguments[0] = 00;
    report->arguments[1] = 04;
    report->arguments[2] = 01;
}
/**
 * Set Async On lift-off distance. Step 2
 */
void set_lod_async_on_step2(struct razer_report *report)
{
    razer_reset_report(report, 0x0b, 0x0b, 0x04);
    report->arguments[0] = 00;
    report->arguments[1] = 04;
    report->arguments[2] = 04;
    report->arguments[3] = 00;
}
/**
 * Set async lift-off distance values
 */
void set_async_lod(struct razer_report *report, uint8_t lod, uint8_t ld)
{
    lod = clamp_u8(lod, 2, 26);
    ld = clamp_u8(ld, 1, 25);
    razer_reset_report(report, 0x0b, 0x05, 0x04);
    report->arguments[0] = 00;
    report->arguments[1] = 04;
    report->arguments[2] = lod - 1;
    report->arguments[3] = ld - 1;
}
